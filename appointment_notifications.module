<?php

use Drupal\node\Entity\Node;
use Drupal\Core\Mail\MailManagerInterface;
use Drupal\Core\Url;

/**
 * Implements hook_entity_insert().
 */
function appointment_notifications_entity_insert(Drupal\Core\Entity\EntityInterface $entity) {
  // Ensure the entity is of type 'node' and the content type is 'appointment'.
  if ($entity instanceof \Drupal\node\Entity\Node && $entity->bundle() === 'appointment') {
    // Send email to the attending member (author).
    _appointment_notifications_send_email($entity, 'member_scheduled');

    // Send email to the host volunteer.
    _appointment_notifications_send_email($entity, 'host_scheduled');
  }
}

/**
 * Implements hook_entity_update().
 */
function appointment_notifications_entity_update(Drupal\Core\Entity\EntityInterface $entity) {
  // Ensure the entity is of type 'node' and the content type is 'appointment'.
  if ($entity instanceof \Drupal\node\Entity\Node && $entity->bundle() === 'appointment') {
    
    // Check if the original entity exists (before the update).
    if ($entity->original) {
      // Get the original (old) value of the appointment status field.
      $original_status = $entity->original->get('field_appointment_status')->value;
  
      // Get the current (new) value of the appointment status field.
      $current_status = $entity->get('field_appointment_status')->value;
  
      // Check if the status has changed from "scheduled" to "canceled".
      if ($original_status === 'scheduled' && $current_status === 'canceled') {
        // Send the cancellation email to both host and member.
        _appointment_notifications_send_email($entity, 'canceled');
      }
  
      // Get the original (old) value of the appointment result field.
      $original_result = $entity->original->get('field_appointment_result')->value;
  
      // Get the current (new) value of the appointment result field.
      $current_result = $entity->get('field_appointment_result')->value;
  
      // Define problem states.
      $problem_states = ['volunteer_absent', 'met_unsuccessful'];
  
      // Check if the result field has changed from a non-problem state to a problem state.
      if (!in_array($original_result, $problem_states) && in_array($current_result, $problem_states)) {
        // Send the problem notification email only if the state has changed to a problem state.
        _appointment_notifications_send_problem_notice($entity);
      }
    }
  }
}

/**
 * Helper function to send emails.
 */
function _process_template_condition($template, $condition, $include_content) {
  $pattern = "/start-if@$condition(.*?)end-if@$condition/s";
  if ($include_content) {
    // If the condition is true, replace the entire block with its content.
    return preg_replace($pattern, '$1', $template);
  } else {
    // If the condition is false, remove the entire block.
    return preg_replace($pattern, '', $template);
  }
}


/**
 * Builds a formatted date and time for the appointment.
 *
 * @param \Drupal\node\Entity\Node $node
 *   The appointment node.
 * @param string|null $start_time_override
 *   Optional override for the host start time (e.g. from request query).
 *
 * @return array
 *   An array with keys:
 *   - date: The formatted appointment date.
 *   - time: The formatted appointment time if available.
 *   - site_timezone: The site timezone used for calculations.
 */
function _appointment_notifications_get_schedule_details(Node $node, $start_time_override = NULL) {
  $site_timezone = \Drupal::config('system.date')->get('timezone.default') ?: 'UTC';

  $formatted_date = 'No date provided';
  $appointment_time = 'Time not specified';
  $start_datetime = NULL;
  $end_datetime = NULL;
  $date_only_string = '';

  $slot_offsets = [
    '1' => 0,
    '1-5' => 30,
    '2' => 60,
    '2-5' => 90,
    '3' => 120,
    '3-5' => 150,
  ];

  $selected_offsets = [];
  if ($node->hasField('field_appointment_slot') && !$node->get('field_appointment_slot')->isEmpty()) {
    foreach ($node->get('field_appointment_slot')->getValue() as $slot) {
      $value = $slot['value'] ?? NULL;
      if ($value !== NULL && isset($slot_offsets[$value])) {
        $selected_offsets[] = $slot_offsets[$value];
      }
    }
  }

  // Capture the standalone appointment date for formatting and time math.
  $raw_date = NULL;
  if ($node->hasField('field_appointment_date') && !$node->get('field_appointment_date')->isEmpty()) {
    $raw_date = $node->get('field_appointment_date')->value;
  }
  if (!empty($raw_date)) {
    try {
      $date = new \DateTime($raw_date);
      $formatted_date = $date->format('l, F j, Y');
      $date_only_string = $date->format('Y-m-d');
    }
    catch (\Exception $e) {
      \Drupal::logger('appointment_notifications')->error('Error formatting appointment date: @message', ['@message' => $e->getMessage()]);
    }
  }

  // Prefer the explicit timerange field when available.
  if (!$start_datetime && $node->hasField('field_appointment_timerange') && !$node->get('field_appointment_timerange')->isEmpty()) {
    $range_item = $node->get('field_appointment_timerange')->first();
    $range_timezone = isset($range_item->timezone) && $range_item->timezone ? $range_item->timezone : $site_timezone;

    $range_start_raw = $range_item->value ?? NULL;
    $range_end_raw = $range_item->end_value ?? NULL;

    try {
      if ($range_start_raw !== NULL && $range_start_raw !== '') {
        $start_datetime = _appointment_notifications_convert_smartdate_value($range_start_raw, $range_timezone)->setTimezone(new \DateTimeZone($site_timezone));
      }
      if ($range_end_raw !== NULL && $range_end_raw !== '') {
        $end_datetime = _appointment_notifications_convert_smartdate_value($range_end_raw, $range_timezone)->setTimezone(new \DateTimeZone($site_timezone));
      }
    }
    catch (\Exception $e) {
      \Drupal::logger('appointment_notifications')->error('Unable to parse timerange for appointment @nid: @message', [
        '@nid' => $node->id(),
        '@message' => $e->getMessage(),
      ]);
      $start_datetime = NULL;
      $end_datetime = NULL;
    }
  }

  $host_start_time_raw = NULL;
  if (!$start_datetime) {
    if ($node->hasField('field_host_start_time') && !$node->get('field_host_start_time')->isEmpty()) {
      $host_start_time_raw = $node->get('field_host_start_time')->value;
    }
    elseif (!empty($start_time_override)) {
      $host_start_time_raw = $start_time_override;
    }
  }

  if (!empty($host_start_time_raw)) {
    $host_time_string = $host_start_time_raw;
    $has_date_component = preg_match('/\d{4}-\d{2}-\d{2}/', $host_start_time_raw);
    if (!$has_date_component && !empty($date_only_string)) {
      $host_time_string = $date_only_string . ' ' . $host_start_time_raw;
    }

    try {
      $base_start = new \DateTimeImmutable($host_time_string, new \DateTimeZone($site_timezone));

      if (!empty($selected_offsets)) {
        $min_offset = min($selected_offsets);
        $duration_minutes = max($selected_offsets) - $min_offset + 30;
      }
      else {
        $min_offset = 0;
        $duration_minutes = 60;
      }

      $start_datetime = $base_start->modify('+' . $min_offset . ' minutes');
      $end_datetime = $start_datetime->modify('+' . $duration_minutes . ' minutes');
      $appointment_time = $start_datetime->format('g:i A');
    }
    catch (\Exception $e) {
      \Drupal::logger('appointment_notifications')->error('Error calculating appointment time: @message', ['@message' => $e->getMessage()]);
    }
  }

  if ($start_datetime instanceof \DateTimeInterface) {
    $formatted_date = $start_datetime->format('l, F j, Y');
    $appointment_time = $start_datetime->format('g:i A');
  }

  return [
    'date' => $formatted_date,
    'time' => $appointment_time,
    'site_timezone' => $site_timezone,
    'start_datetime' => $start_datetime,
    'end_datetime' => $end_datetime,
  ];
}

/**
 * Builds the absolute feedback URL for appointment follow-ups.
 *
 * @return string
 *   The feedback URL as a string.
 */
function _appointment_notifications_feedback_link(): string {
  try {
    return Url::fromUserInput('/appointments/feedback', ['absolute' => TRUE])->toString();
  }
  catch (\Exception $e) {
    return '/appointments/feedback';
  }
}

/**
 * Converts Smart Date raw values (timestamp or string) to DateTimeImmutable.
 *
 * @param string|int $value
 *   The stored Smart Date value.
 * @param string $timezone
 *   The timezone to apply to the value.
 *
 * @return \DateTimeImmutable
 *   A DateTimeImmutable object in the provided timezone.
 */
function _appointment_notifications_convert_smartdate_value($value, string $timezone): \DateTimeImmutable {
  if (is_numeric($value)) {
    $timestamp = (int) $value;
    $date = new \DateTimeImmutable('@' . $timestamp);
    return $date->setTimezone(new \DateTimeZone($timezone));
  }
  return new \DateTimeImmutable($value, new \DateTimeZone($timezone));
}

/**
 * Determines whether a notification should be sent for a node on a given date.
 *
 * @param \Drupal\node\Entity\Node $node
 *   The appointment node.
 * @param string $type
 *   The notification type (e.g. 'feedback', 'member_reminder').
 * @param string $date_value
 *   The date value used to deduplicate sends (format: Y-m-d).
 *
 * @return bool
 *   TRUE if the notification should be sent, FALSE if it was already sent.
 */
function _appointment_notifications_should_send(Node $node, $type, $date_value) {
  $state = \Drupal::state();
  $sent = $state->get('appointment_notifications.sent.' . $type, []);
  return !isset($sent[$node->id()]) || $sent[$node->id()] !== $date_value;
}

/**
 * Marks that a notification has been sent for a node on a given date.
 *
 * @param \Drupal\node\Entity\Node $node
 *   The appointment node.
 * @param string $type
 *   The notification type (e.g. 'feedback', 'member_reminder').
 * @param string $date_value
 *   The date value used to deduplicate sends (format: Y-m-d).
 */
function _appointment_notifications_mark_sent(Node $node, $type, $date_value) {
  $state = \Drupal::state();
  $key = 'appointment_notifications.sent.' . $type;
  $sent = $state->get($key, []);
  $sent[$node->id()] = $date_value;
  $state->set($key, $sent);
}

/**
 * Escapes text for use within an ICS file.
 *
 * @param string $value
 *   The string to escape.
 *
 * @return string
 *   The escaped string.
 */
function _appointment_notifications_ics_escape($value) {
  $value = (string) $value;
  $value = str_replace(['\\', ';', ','], ['\\\\', '\\;', '\\,'], $value);
  $value = preg_replace("/(\r\n|\r|\n)/", '\\n', $value);
  return $value;
}

/**
 * Builds a calendar invite attachment for an appointment notification.
 *
 * @param \Drupal\node\Entity\Node $node
 *   The appointment node.
 * @param array $schedule_details
 *   The schedule details array returned by
 *   _appointment_notifications_get_schedule_details().
 * @param string $action
 *   The notification action (e.g. 'member_scheduled', 'canceled').
 * @param array $participants
 *   A list of participant arrays with keys: email, name.
 * @param array $context
 *   Additional context such as date, time, purpose, note, and link.
 *
 * @return array|null
 *   The attachment array suitable for Drupal mail, or NULL if an invite
 *   cannot be generated.
 */
function _appointment_notifications_build_calendar_attachment(Node $node, array $schedule_details, $action, array $participants = [], array $context = []) {
  $start = $schedule_details['start_datetime'] ?? NULL;
  $end = $schedule_details['end_datetime'] ?? NULL;

  if ($start instanceof \DateTimeInterface && !$end instanceof \DateTimeInterface) {
    $end = $start->modify('+60 minutes');
  }

  if (!$start instanceof \DateTimeInterface || !$end instanceof \DateTimeInterface) {
    return NULL;
  }

  $method = ($action === 'canceled') ? 'CANCEL' : 'REQUEST';
  $status = ($method === 'CANCEL') ? 'CANCELLED' : 'CONFIRMED';
  $sequence = ($method === 'CANCEL') ? 1 : 0;

  $config = \Drupal::config('appointment_notifications.settings');
  $organizer_email = $config->get('email_sender') ?: 'no-reply@example.com';
  $site_name = \Drupal::config('system.site')->get('name') ?: 'MakeHaven';

  $uid = 'appointment-' . $node->id() . '@makehaven.org';
  $dtstamp = (new \DateTimeImmutable('now', new \DateTimeZone('UTC')))->format('Ymd\THis\Z');
  $dtstart = $start->setTimezone(new \DateTimeZone('UTC'))->format('Ymd\THis\Z');
  $dtend = $end->setTimezone(new \DateTimeZone('UTC'))->format('Ymd\THis\Z');

  $summary = _appointment_notifications_ics_escape($node->getTitle());
  $description_parts = [];

  if (!empty($context['date']) && !empty($context['time']) && $context['time'] !== 'Time not specified') {
    $description_parts[] = 'When: ' . $context['date'] . ' at ' . $context['time'];
  }

  if (!empty($context['purpose']) && $context['purpose'] !== 'No purpose provided') {
    $description_parts[] = 'Purpose: ' . $context['purpose'];
  }

  if (!empty($context['note']) && $context['note'] !== 'No additional notes') {
    $description_parts[] = 'Notes: ' . $context['note'];
  }

  if (!empty($context['link'])) {
    $description_parts[] = 'Details: ' . $context['link'];
  }

  $description = !empty($description_parts)
    ? _appointment_notifications_ics_escape(implode("\n", $description_parts))
    : '';

  $lines = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//MakeHaven//Appointment Notifications//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:' . $method,
    'BEGIN:VEVENT',
    'UID:' . $uid,
    'SEQUENCE:' . $sequence,
    'DTSTAMP:' . $dtstamp,
    'DTSTART:' . $dtstart,
    'DTEND:' . $dtend,
    'STATUS:' . $status,
    'SUMMARY:' . $summary,
  ];

  if (!empty($description)) {
    $lines[] = 'DESCRIPTION:' . $description;
  }

  $lines[] = 'ORGANIZER;CN=' . _appointment_notifications_ics_escape($site_name) . ':mailto:' . $organizer_email;

  foreach ($participants as $participant) {
    if (empty($participant['email'])) {
      continue;
    }
    $participant_name = !empty($participant['name']) ? $participant['name'] : $participant['email'];
    $lines[] = 'ATTENDEE;CN=' . _appointment_notifications_ics_escape($participant_name) . ';ROLE=REQ-PARTICIPANT:mailto:' . $participant['email'];
  }

  if (!empty($context['link'])) {
    $lines[] = 'URL:' . _appointment_notifications_ics_escape($context['link']);
  }

  $lines[] = 'TRANSP:OPAQUE';
  $lines[] = 'END:VEVENT';
  $lines[] = 'END:VCALENDAR';

  $content = implode("\r\n", $lines) . "\r\n";

  return [
    'filename' => 'appointment-' . $node->id() . '.ics',
    'filecontent' => $content,
    'filemime' => 'text/calendar; charset=UTF-8; method=' . $method,
  ];
}


function _appointment_notifications_send_email(Node $node, $action) {
  $mailManager = \Drupal::service('plugin.manager.mail');
  $config = \Drupal::config('appointment_notifications.settings');
  $module = 'appointment_notifications';
  $key = 'appointment_' . $action;
  $language = \Drupal::currentUser()->getPreferredLangcode();
  $sender = $config->get('email_sender');
  $development_mode = $config->get('development_mode');
  $email_logging = $config->get('email_logging');

  // Slack Team ID
  $slack_team_id = 'T02DJKD4B'; // Replace with your actual Slack Team ID

  $request_stack = \Drupal::service('request_stack');
  $current_request = $request_stack->getCurrentRequest();
  $start_time_override = $current_request ? $current_request->query->get('start_time') : NULL;
  $schedule_details = _appointment_notifications_get_schedule_details($node, $start_time_override);
  $formatted_date = $schedule_details['date'];
  $appointment_time = $schedule_details['time'];

  /**
   * Helper function to load the user's profile and get a field value.
   */
  if (!function_exists('_get_profile_field_value')) {
    function _get_profile_field_value($user, $profile_type, $field_name) {
      $profile = \Drupal::entityTypeManager()
        ->getStorage('profile')
        ->loadByProperties(['uid' => $user->id(), 'type' => $profile_type]);

      if (!empty($profile)) {
        $profile_entity = reset($profile); // Get the first profile entity.
        if ($profile_entity->hasField($field_name) && !$profile_entity->get($field_name)->isEmpty()) {
          return $profile_entity->get($field_name)->value;
        }
      }
      return 'Not available'; // Default if field is missing or empty.
    }
  }

  // Prepare the member's email, name, and Slack ID.
  $member_user = $node->getOwner();
  $member_email = ($member_user && $member_user->getEmail()) ? $member_user->getEmail() : '';
  $member_email_display = $member_email ?: 'No email available';
  $member_name = $member_user ? $member_user->getDisplayName() : 'Not specified';
  $member_slack_id = _get_profile_field_value($member_user, 'main', 'field_member_slack_id_number');
  $member_slack_link = $member_slack_id && $member_slack_id !== 'Not available'
      ? 'https://makehaven.slack.com/team/' . $member_slack_id
      : 'Not available';

  // Prepare the host's email, name, and Slack ID.
  $host_user = $node->hasField('field_appointment_host') && !$node->get('field_appointment_host')->isEmpty()
      ? $node->get('field_appointment_host')->entity
      : null;

  $host_email = ($host_user && $host_user->getEmail()) ? $host_user->getEmail() : '';
  $host_email_display = $host_email ?: 'No email available';
  $host_name = $host_user ? $host_user->getDisplayName() : 'Not specified';
  $host_slack_id = $host_user ? _get_profile_field_value($host_user, 'main', 'field_member_slack_id_number') : 'Not available';
  $host_slack_link = $host_slack_id !== 'Not available'
      ? 'https://makehaven.slack.com/team/' . $host_slack_id
      : 'Not available';

  // [New Code] Determine the appointment purpose.
  $purpose = $node->get('field_appointment_purpose')->value ?? 'No purpose provided';

  // [New Code] Determine if the 'checkout_instructions' should be included.
  $include_checkout_instructions = ($purpose === 'checkout');
  $badge_names = [];
  if ($node->hasField('field_appointment_badges') && !$node->get('field_appointment_badges')->isEmpty()) {
    foreach ($node->get('field_appointment_badges')->referencedEntities() as $badge) {
      $badge_names[] = $badge->label();
    }
  }

  $appointment_link = Url::fromRoute('entity.node.canonical', ['node' => $node->id()], ['absolute' => TRUE])->toString();
  $appointment_feedback_value = $node->get('field_appointment_feedback')->value ?? 'No feedback available';
  $appointment_result_value = $node->get('field_appointment_result')->value ?? 'No result provided';
  $appointment_note_value = $node->get('field_appointment_note')->value ?? 'No additional notes';

  // Prepare replacements shared by all recipients.
  $base_replacements = [
    '@title' => $node->getTitle(),
    '@date' => $formatted_date,
    '@time' => $appointment_time,
    '@purpose' => $purpose,
    '@feedback' => $appointment_feedback_value,
    '@result' => $appointment_result_value,
    '@link' => $appointment_link,
    '@feedback_link' => _appointment_notifications_feedback_link(),
    '@scheduled_by' => $member_name ?? 'Not specified',
    '@badges' => !empty($badge_names) ? implode(', ', $badge_names) : 'None selected',
    '@note' => $appointment_note_value,
    '@volunteer_name' => $host_name ?: 'Not specified',
    '@member_email' => $member_email_display,
    '@member_slack_id' => $member_slack_id,
    '@member_slack_link' => $member_slack_link,
    '@host_email' => $host_email_display,
    '@host_slack_id' => $host_slack_id,
    '@host_slack_link' => $host_slack_link,
  ];

  // Load templates.
  $subject_template = $config->get("email_subject_$action") ?? 'Appointment Notification';
  $body_template = $config->get("email_body_$action") ?? 'Default email body content';

  // Process conditional blocks in the template.
  $body_template = _process_template_condition($body_template, 'checkout_instructions', $include_checkout_instructions);

  $participants = [];
  if (!empty($member_email)) {
    $participants[] = ['email' => $member_email, 'name' => $member_name];
  }
  if (!empty($host_email)) {
    $participants[] = ['email' => $host_email, 'name' => $host_name];
  }

  $calendar_context = [
    'date' => $formatted_date,
    'time' => $appointment_time,
    'purpose' => $purpose,
    'note' => trim(strip_tags($appointment_note_value)),
    'link' => $appointment_link,
  ];

  $calendar_attachment = NULL;
  if ($config->get('calendar_invites_enabled') && in_array($action, ['member_scheduled', 'host_scheduled', 'canceled'], TRUE)) {
    $calendar_attachment = _appointment_notifications_build_calendar_attachment($node, $schedule_details, $action, $participants, $calendar_context);
  }

  // Build recipient definitions.
  $recipient_definitions = [];
  switch ($action) {
    case 'member_scheduled':
    case 'member_reminder':
      if (!empty($member_email)) {
        $recipient_definitions[] = [
          'email' => $member_email,
          'name' => $member_name ?: 'Member',
          'cc' => [],
        ];
      }
      break;

    case 'host_scheduled':
    case 'host_reminder':
      if (!empty($host_email)) {
        $recipient_definitions[] = [
          'email' => $host_email,
          'name' => $host_name ?: 'Volunteer',
          'cc' => [],
        ];
      }
      break;

    case 'canceled':
      if (!empty($member_email)) {
        $recipient_definitions[] = [
          'email' => $member_email,
          'name' => $member_name ?: 'Member',
          'cc' => [],
        ];
      }
      if (!empty($host_email)) {
        $cc_list = !empty($member_email) ? [$member_email] : [];
        $recipient_definitions[] = [
          'email' => $host_email,
          'name' => $host_name ?: 'Volunteer',
          'cc' => $cc_list,
        ];
      }
      break;

    default:
      if (!empty($member_email)) {
        $recipient_definitions[] = [
          'email' => $member_email,
          'name' => $member_name ?: 'Member',
          'cc' => [],
        ];
      }
      break;
  }

  if (empty($recipient_definitions)) {
    \Drupal::logger('appointment_notifications')->warning('No recipients found for action @action.', ['@action' => $action]);
    return FALSE;
  }

  $any_success = FALSE;

  foreach ($recipient_definitions as $recipient) {
    $recipient_name = !empty($recipient['name']) ? $recipient['name'] : 'Not specified';
    $replacements = $base_replacements + [
      '@recipient_name' => $recipient_name,
    ];

    $subject = strtr($subject_template, $replacements);
    $body = strtr($body_template, $replacements);

    $subject = trim($subject) ?: 'Appointment Notification';
    $body = trim($body) ?: 'This is a fallback email body since the template content was empty.';

    if ($email_logging) {
      \Drupal::logger('appointment_notifications')->notice('Email (@action) prepared for @recipient with subject "@subject". Body: @body', [
        '@action' => $action,
        '@recipient' => $recipient['email'],
        '@subject' => $subject,
        '@body' => $body,
      ]);
    }

    if ($development_mode) {
      $any_success = TRUE;
      continue;
    }

    $params = [
      'subject' => $subject,
      'message' => $body,
      'cc' => !empty($recipient['cc']) ? implode(', ', $recipient['cc']) : '',
    ];
    if ($calendar_attachment) {
      $params['attachments'] = [$calendar_attachment];
    }
    $result = $mailManager->mail($module, $key, $recipient['email'], $language, $params, $sender);
    if (!empty($result['result'])) {
      $any_success = TRUE;
    }
    else {
      \Drupal::logger('appointment_notifications')->error('Failed to send email to @recipient for action @action', [
        '@recipient' => $recipient['email'],
        '@action' => $action,
      ]);
    }
  }

  return $any_success;
}







/**
 * Implements hook_cron().
 */
function appointment_notifications_cron() {
  $config = \Drupal::config('appointment_notifications.settings');
  $site_timezone = \Drupal::config('system.date')->get('timezone.default') ?: 'UTC';
  $now = new \DateTime('now', new \DateTimeZone($site_timezone));
  $feedback_date = (clone $now)->modify('-1 day')->format('Y-m-d');

  $nids = \Drupal::entityQuery('node')
    ->condition('type', 'appointment')
    ->condition('field_appointment_status', 'scheduled')
    ->condition('field_appointment_date', $feedback_date)
    ->accessCheck(FALSE)
    ->execute();

  if (empty($nids)) {
    return;
  }

  $nodes = Node::loadMultiple($nids);

  foreach ($nodes as $node) {
    if (_appointment_notifications_should_send($node, 'feedback', $feedback_date)) {
      if (_appointment_notifications_send_feedback_invitation($node)) {
        _appointment_notifications_mark_sent($node, 'feedback', $feedback_date);
      }
    }
  }

  if ($config->get('reminder_enabled')) {
    $days_before = (int) ($config->get('reminder_days_before') ?? 1);
    $days_before = max(1, $days_before);
    $reminder_date = (clone $now)->modify('+' . $days_before . ' day')->format('Y-m-d');

    $reminder_nids = \Drupal::entityQuery('node')
      ->condition('type', 'appointment')
      ->condition('field_appointment_status', 'scheduled')
      ->condition('field_appointment_date', $reminder_date)
      ->accessCheck(FALSE)
      ->execute();

    if (!empty($reminder_nids)) {
      $reminder_nodes = Node::loadMultiple($reminder_nids);

      foreach ($reminder_nodes as $node) {
        $member = $node->getOwner();
        if ($member && $member->getEmail() && _appointment_notifications_should_send($node, 'member_reminder', $reminder_date)) {
          if (_appointment_notifications_send_email($node, 'member_reminder')) {
            _appointment_notifications_mark_sent($node, 'member_reminder', $reminder_date);
          }
        }

        $host_user = $node->hasField('field_appointment_host') && !$node->get('field_appointment_host')->isEmpty()
          ? $node->get('field_appointment_host')->entity
          : NULL;
        $host_email = ($host_user && $host_user->getEmail()) ? $host_user->getEmail() : '';

        if (!empty($host_email) && _appointment_notifications_should_send($node, 'host_reminder', $reminder_date)) {
          if (_appointment_notifications_send_email($node, 'host_reminder')) {
            _appointment_notifications_mark_sent($node, 'host_reminder', $reminder_date);
          }
        }
      }
    }
  }
}

/**
 * Helper function to send a feedback invitation email.
 */
function _appointment_notifications_send_feedback_invitation(Node $node) {
  $mailManager = \Drupal::service('plugin.manager.mail');
  $config = \Drupal::config('appointment_notifications.settings');
  $module = 'appointment_notifications';
  $key = 'appointment_feedback_invitation';
  $language = \Drupal::currentUser()->getPreferredLangcode();
  $sender = $config->get('email_sender');
  $development_mode = $config->get('development_mode');
  $email_logging = $config->get('email_logging');

  $member = $node->getOwner();
  if (!$member || !$member->getEmail()) {
    \Drupal::logger('appointment_notifications')->warning('Unable to send feedback invitation for appointment @nid because the member has no email.', [
      '@nid' => $node->id(),
    ]);
    return FALSE;
  }

  $schedule_details = _appointment_notifications_get_schedule_details($node);

  // Prepare replacements.
  $replacements = [
    '@title' => $node->getTitle(),
    '@date' => $schedule_details['date'],
    '@time' => $schedule_details['time'],
    '@recipient_name' => $member->getDisplayName() ?: 'Member',
    '@link' => Url::fromRoute('entity.node.canonical', ['node' => $node->id()], ['absolute' => TRUE])->toString(),
    '@feedback_link' => _appointment_notifications_feedback_link(),
  ];

  // Load templates.
  $subject_template = $config->get("email_subject_feedback_invitation") ?? 'Feedback for your appointment';
  $body_template = $config->get("email_body_feedback_invitation") ?? 'Please provide feedback for your appointment on @date.';

  // Replace tokens.
  $subject = strtr($subject_template, $replacements);
  $body = strtr($body_template, $replacements);

  // Ensure subject and body are not empty.
  $subject = trim($subject) ?: 'Feedback for your appointment';
  $body = trim($body) ?: 'This is a fallback email body since the template content was empty.';

  if ($email_logging) {
    \Drupal::logger('appointment_notifications')->notice('Feedback invitation prepared for @recipient with subject "@subject". Body: @body', [
      '@recipient' => $member->getEmail(),
      '@subject' => $subject,
      '@body' => $body,
    ]);
  }

  if ($development_mode) {
    return TRUE;
  }

  $params = ['subject' => $subject, 'message' => $body];
  $result = $mailManager->mail($module, $key, $member->getEmail(), $language, $params, $sender);
  if (!empty($result['result'])) {
    return TRUE;
  }

  \Drupal::logger('appointment_notifications')->error('Failed to send feedback invitation to @recipient', [
    '@recipient' => $member->getEmail(),
  ]);
  return FALSE;
}

/**
 * Helper function to send a problem notice to staff.
 */
function _appointment_notifications_send_problem_notice(Node $node) {
  $mailManager = \Drupal::service('plugin.manager.mail');
  $config = \Drupal::config('appointment_notifications.settings');
  $module = 'appointment_notifications';
  $key = 'appointment_problem_notice';
  $language = \Drupal::currentUser()->getPreferredLangcode();
  $sender = $config->get('email_sender');
  $to_emails = explode(',', $config->get('staff_email'));
  $development_mode = $config->get('development_mode');
  $email_logging = $config->get('email_logging');

  // Prepare replacement patterns.
  $replacements = [
    '@title' => $node->getTitle(),
    '@date' => $node->get('field_appointment_date')->value,
    '@result' => $node->get('field_appointment_result')->value,
    '@feedback' => $node->get('field_appointment_feedback')->value,
    '@author_name' => $node->getOwner()->getDisplayName(), // Name of the person who had the problem
    '@volunteer_name' => '', // Placeholder for volunteer name
    '@link' => Url::fromRoute('entity.node.canonical', ['node' => $node->id()], ['absolute' => TRUE])->toString(),
  ];

  // Initialize volunteer/host name as 'Not specified' by default.
  $volunteer_name = 'Not specified';

  // Check if the field_appointment_host field exists and has a value.
  if ($node->hasField('field_appointment_host') && !$node->get('field_appointment_host')->isEmpty()) {
    $host_user = $node->get('field_appointment_host')->entity;

    if ($host_user) {
      $volunteer_name = $host_user->getDisplayName();
      \Drupal::logger('appointment_notifications')->debug('Host user found: @name', ['@name' => $volunteer_name]);
    } else {
      \Drupal::logger('appointment_notifications')->warning('Host user entity is not loaded or is empty.');
    }
  } else {
    \Drupal::logger('appointment_notifications')->warning('field_appointment_host is missing or empty.');
  }

  // Assign the volunteer name to the replacement array.
  $replacements['@volunteer_name'] = $volunteer_name;

  // Load templates.
  $subject_template = $config->get("email_subject_problem_notice") ?? 'Issue Reported During Appointment - @title';
  $body_template = $config->get("email_body_problem_notice") ?? 'An issue has been reported during an appointment.';

  // Replace tokens.
  $subject = strtr($subject_template, $replacements);
  $body = strtr($body_template, $replacements);

  // Ensure subject and body are not empty.
  $subject = trim($subject) ?: 'Issue Reported During Appointment';
  $body = trim($body) ?: 'This is a fallback email body since the template content was empty.';

  if ($email_logging) {
    \Drupal::logger('appointment_notifications')->notice('Problem email to be sent to @recipients with subject "@subject". Body: @body', [
      '@recipients' => implode(',', $to_emails),
      '@subject' => $subject,
      '@body' => $body,
    ]);
  }

  if (!$development_mode) {
    foreach ($to_emails as $to) {
      $params = ['subject' => $subject, 'message' => $body];
      $result = $mailManager->mail($module, $key, trim($to), $language, $params, $sender);
      if ($result['result'] !== true) {
        \Drupal::logger('appointment_notifications')->error('Failed to send problem email to @recipient', ['@recipient' => $to]);
      }
    }
  }
}

/**
 * Implements hook_mail().
 */
function appointment_notifications_mail($key, &$message, $params) {
  switch ($key) {
    case 'appointment_member_scheduled':
    case 'appointment_host_scheduled':
    case 'appointment_canceled':
    case 'appointment_problem_notice':
    case 'appointment_feedback_invitation':
    case 'appointment_member_reminder':
    case 'appointment_host_reminder':
      $message['subject'] = $params['subject'];
      $message['body'][] = $params['message'];
      if (!empty($params['attachments'])) {
        $message['attachments'] = $params['attachments'];
      }
      break;

    default:
      \Drupal::logger('appointment_notifications')->warning('Unhandled mail key: @key', ['@key' => $key]);
      break;
  }
}
